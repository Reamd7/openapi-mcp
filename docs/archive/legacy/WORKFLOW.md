# 工作流程方法论 - 瀑布模型

## 目录
- [瀑布模型概述](#瀑布模型概述)
- [开发流程](#开发流程)
- [任务管理](#任务管理)
- [测试流程](#测试流程)
- [进度追踪](#进度追踪)

---

## 瀑布模型概述

本项目采用**经典瀑布模型 (Waterfall Model)** 进行软件开发,严格按照阶段顺序推进,每个阶段必须完全完成并通过评审后才能进入下一阶段。

### 瀑布模型特点
- **阶段性**: 开发过程划分为明确的阶段
- **顺序性**: 阶段按严格顺序执行,不可逆转
- **文档驱动**: 每个阶段产出明确的文档
- **评审门控**: 每个阶段结束需要评审通过

### 瀑布模型阶段

```
┌──────────────────┐
│  1. 需求分析     │  → 输出: PLAN.md
├──────────────────┤
│  2. 系统设计     │  → 输出: 接口设计文档, 类型定义
├──────────────────┤
│  3. 实现编码     │  → 输出: 源代码
├──────────────────┤
│  4. 测试验证     │  → 输出: 测试报告
├──────────────────┤
│  5. 部署发布     │  → 输出: 可发布的软件包
├──────────────────┤
│  6. 维护迭代     │  → 输出: 更新和补丁
└──────────────────┘
```

---

## 开发流程

### 阶段 1: 需求分析 (Requirements Analysis)

**目标**: 明确项目需求,定义功能范围

**活动**:
1. 收集和分析用户需求
2. 定义功能需求和非功能需求
3. 确定技术栈和依赖
4. 编写需求规格说明书

**输出文档**:
- ✅ `PLAN.md` - 详细开发计划
- ✅ `WORKFLOW.md` - 工作流程方法论
- ✅ `PROGRESS.md` - 任务进度追踪模板

**完成标准**:
- [ ] 需求文档完整清晰
- [ ] 技术选型确定
- [ ] 项目范围明确
- [ ] 用户确认需求

**评审检查点**: 用户确认需求文档 ✅

---

### 阶段 2: 系统设计 (System Design)

**目标**: 设计系统架构和模块接口

**活动**:
1. 设计整体架构
2. 定义模块划分和接口
3. 设计数据结构
4. 设计 MCP 工具规格

**输出文档**:
- [ ] `src/types.ts` - 完整的类型定义
- [ ] 各模块接口设计(仅接口,不实现)
- [ ] 架构设计文档(可选)

**完成标准**:
- [ ] 所有接口定义完成
- [ ] TypeScript 类型定义完整
- [ ] 模块依赖关系清晰
- [ ] 接口设计评审通过

**评审检查点**: 设计文档评审通过

---

### 阶段 3: 实现编码 (Implementation)

**目标**: 按照设计实现所有功能

**活动**: 按子阶段顺序实现

#### 子阶段 3.1: 项目初始化
- 创建目录结构
- 配置开发环境
- 安装依赖

#### 子阶段 3.2: 基础设施层
- 实现 OpenAPI Loader (本地文件 + HTTP)
- 实现 OpenAPI Parser
- 实现索引构建

#### 子阶段 3.3: 业务逻辑层
- 实现所有 6 个 MCP 工具
- 实现工具注册中心

#### 子阶段 3.4: 服务层
- 实现 MCP Server
- 实现命令行入口
- 集成所有模块

**输出文档**:
- [ ] 完整的源代码
- [ ] 代码注释和 JSDoc
- [ ] 构建脚本

**完成标准**:
- [ ] 所有功能实现完成
- [ ] TypeScript 编译无错误
- [ ] 代码符合规范
- [ ] 代码评审通过

**评审检查点**: 代码实现评审

---

### 阶段 4: 测试验证 (Testing & Verification)

**目标**: 全面测试系统功能和质量

**活动**: 按测试层级进行

#### 4.1 单元测试
- 测试每个函数和模块
- 代码覆盖率 > 80%

#### 4.2 集成测试
- 测试模块间交互
- 测试完整数据流

#### 4.3 系统测试
- 端到端功能测试
- 性能测试
- Claude Desktop 集成测试

#### 4.4 验收测试
- 用户场景测试
- 需求符合性验证

**输出文档**:
- [ ] 测试用例文档
- [ ] 测试报告
- [ ] Bug 修复记录

**完成标准**:
- [ ] 所有测试通过
- [ ] 无严重 Bug
- [ ] 性能达标
- [ ] 用户验收通过

**评审检查点**: 测试报告评审

---

### 阶段 5: 部署发布 (Deployment)

**目标**: 准备软件发布

**活动**:
1. 编写用户文档
2. 创建使用示例
3. 打包发布
4. 发布说明

**输出文档**:
- [ ] `README.md` - 用户文档
- [ ] 使用示例
- [ ] 发布包

**完成标准**:
- [ ] 文档完整
- [ ] 示例可运行
- [ ] 发布包可用
- [ ] 发布评审通过

**评审检查点**: 发布评审

---

### 阶段 6: 维护迭代 (Maintenance)

**目标**: 修复 Bug,优化功能

**活动**:
1. 收集用户反馈
2. 修复发现的问题
3. 性能优化
4. 功能增强(如需)

**输出文档**:
- [ ] 更新日志
- [ ] 补丁版本

---

## 需求拆分原则

按照瀑布模型,每个阶段拆分为:

```
阶段 N
  ├─ 子任务 N.1
  │   ├─ 设计
  │   ├─ 实现
  │   ├─ 自测
  │   └─ 文档
  ├─ 子任务 N.2
  │   └─ ...
  └─ 阶段评审
```

### 任务执行流程 (瀑布模型)

```
阶段 1: 需求分析
    ↓ (需求评审通过)
阶段 2: 系统设计
    ↓ (设计评审通过)
阶段 3: 实现编码
    ↓ (代码评审通过)
阶段 4: 测试验证
    ↓ (测试评审通过)
阶段 5: 部署发布
    ↓ (发布评审通过)
阶段 6: 维护迭代

注意: 原则上不允许回退到上一阶段,如必须回退需记录原因
```

### 每个子任务的标准步骤

1. **设计**: 定义接口和数据结构(仅在设计阶段)
2. **实现**: 编写功能代码(仅在实现阶段)
3. **自测**: 基本功能验证
4. **单元测试**: 编写测试(在测试阶段集中进行)
5. **记录**: 更新 PROGRESS.md

---

## 任务管理

### 任务分类

任务分为 **7 个阶段**,每个阶段包含多个子任务:

#### 阶段 1: 项目初始化
#### 阶段 2: OpenAPI 加载器
#### 阶段 3: OpenAPI 解析器
#### 阶段 4: MCP 工具实现
#### 阶段 5: MCP Server 实现
#### 阶段 6: 测试和示例
#### 阶段 7: 文档和发布

### 任务状态定义

- **TODO**: 未开始
- **IN_PROGRESS**: 进行中
- **TESTING**: 开发完成,测试中
- **DONE**: 已完成并测试通过
- **BLOCKED**: 被阻塞

### 任务依赖关系

```
阶段 1 (项目初始化)
  └─> 阶段 2 (加载器) + 阶段 3 (解析器) [可并行]
        └─> 阶段 4 (MCP 工具)
              └─> 阶段 5 (MCP Server)
                    └─> 阶段 6 (测试)
                          └─> 阶段 7 (文档)
```

---

## 测试流程

### 测试层级

#### 1. 单元测试 (Unit Tests)
- **何时**: 每个模块/函数完成后立即编写
- **目标**: 测试单个函数/类的功能
- **工具**: Jest / Mocha + Chai
- **覆盖率目标**: > 80%

#### 2. 集成测试 (Integration Tests)
- **何时**: 模块间交互完成后
- **目标**: 测试模块间协作
- **示例**:
  - Loader + Parser 集成
  - Parser + Tools 集成
  - Tools + Server 集成

#### 3. 端到端测试 (E2E Tests)
- **何时**: 整个系统完成后
- **目标**: 模拟真实使用场景
- **示例**:
  - 加载真实 OpenAPI 文件
  - 调用所有 MCP 工具
  - 验证输出格式

#### 4. 手动测试
- **何时**: 每个阶段完成后
- **目标**: 验证实际使用体验
- **场景**:
  - 在 Claude Desktop 中测试
  - 测试各种 OpenAPI 文件
  - 测试错误场景

### 测试检查清单

每个功能完成后必须通过以下检查:

- [ ] 单元测试通过
- [ ] 集成测试通过
- [ ] 边界条件测试
- [ ] 错误处理测试
- [ ] 性能测试 (如适用)
- [ ] 手动功能验证
- [ ] 代码格式检查
- [ ] TypeScript 类型检查

---

## 进度追踪

### 进度文档结构

使用 `PROGRESS.md` 文件记录详细进度:

```markdown
# 任务进度追踪

## 当前状态
- 当前阶段: X
- 进度: X/Y 任务完成
- 预计完成时间: YYYY-MM-DD

## 阶段 N: [阶段名称]

### 任务 N.1: [任务名称]
- **状态**: DONE
- **负责人**: [名字]
- **开始时间**: YYYY-MM-DD HH:MM
- **完成时间**: YYYY-MM-DD HH:MM
- **测试状态**: PASSED
- **说明**: [完成的功能描述]
- **测试结果**:
  - [x] 单元测试通过
  - [x] 集成测试通过
  - [x] 手动测试通过
- **相关文件**:
  - `src/xxx.ts`
  - `tests/xxx.test.ts`
- **备注**: [如有问题或注意事项]
```

### 每日进度更新

每天结束时更新:
1. 今日完成的任务
2. 遇到的问题
3. 明日计划

### 里程碑

- **M1**: 项目初始化完成
- **M2**: 加载器和解析器完成
- **M3**: 所有 MCP 工具完成
- **M4**: MCP Server 完成
- **M5**: 测试全部通过
- **M6**: 文档完成,可发布

---

## 具体工作流示例

### 示例: 实现 `list-endpoints` 工具

#### 步骤 1: 接口设计
```typescript
// 1. 在 PROGRESS.md 中标记任务为 IN_PROGRESS
// 2. 定义接口
interface ListEndpointsParams {
  method?: string;
  tag?: string;
  limit?: number;
  offset?: number;
}

interface ListEndpointsResult {
  endpoints: Endpoint[];
  total: number;
  limit: number;
  offset: number;
}
```

#### 步骤 2: 实现功能
```typescript
// 3. 实现 list-endpoints.ts
export function listEndpoints(params: ListEndpointsParams): ListEndpointsResult {
  // ... 实现代码
}
```

#### 步骤 3: 单元测试
```typescript
// 4. 编写测试 tests/list-endpoints.test.ts
describe('listEndpoints', () => {
  it('should list all endpoints', () => { ... });
  it('should filter by method', () => { ... });
  it('should filter by tag', () => { ... });
  it('should paginate results', () => { ... });
});

// 5. 运行测试
npm test
```

#### 步骤 4: 集成测试
```typescript
// 6. 测试与 Parser 的集成
describe('listEndpoints integration', () => {
  it('should work with real OpenAPI file', () => { ... });
});
```

#### 步骤 5: 手动测试
```bash
# 7. 在实际环境中测试
node build/index.js ./examples/petstore.yaml
# 然后在 Claude Desktop 中调用 list_endpoints 工具
```

#### 步骤 6: 更新文档
```markdown
# 8. 更新 PROGRESS.md
### 任务 4.2: 实现 list-endpoints 工具
- **状态**: DONE
- **完成时间**: 2024-01-15 16:30
- **测试状态**: PASSED
- **测试结果**:
  - [x] 单元测试通过 (8/8)
  - [x] 集成测试通过 (3/3)
  - [x] 手动测试通过
- **相关文件**:
  - `src/tools/list-endpoints.ts`
  - `tests/list-endpoints.test.ts`
```

---

## 代码规范

### TypeScript 规范
- 所有函数必须有类型注解
- 使用接口定义复杂类型
- 避免使用 `any`,使用 `unknown` 代替
- 导出的函数必须有 JSDoc 注释

### 文件组织
- 一个文件一个主要功能/类
- 相关的类型定义放在 `types.ts`
- 工具函数放在 `utils.ts`

### 命名规范
- 文件名: `kebab-case.ts`
- 类名: `PascalCase`
- 函数名: `camelCase`
- 常量: `UPPER_SNAKE_CASE`
- 接口: `PascalCase` (加 `I` 前缀可选)

### Git Commit 规范
```
<type>(<scope>): <subject>

<body>

<footer>
```

类型:
- `feat`: 新功能
- `fix`: 修复
- `test`: 测试
- `docs`: 文档
- `refactor`: 重构
- `chore`: 构建/工具

示例:
```
feat(loader): 添加 HTTP URL 加载支持

- 实现 axios 请求
- 添加错误处理
- 添加单元测试

Closes #123
```

---

## 质量检查清单

每个阶段完成前必须检查:

### 代码质量
- [ ] TypeScript 编译无错误
- [ ] ESLint 无错误
- [ ] 所有测试通过
- [ ] 代码覆盖率达标
- [ ] 无明显性能问题

### 功能完整性
- [ ] 所有需求功能已实现
- [ ] 边界情况已处理
- [ ] 错误处理完善
- [ ] 日志记录合理

### 文档完整性
- [ ] 代码有注释
- [ ] README 更新
- [ ] API 文档完整
- [ ] 示例代码可运行

### 可维护性
- [ ] 代码结构清晰
- [ ] 无重复代码
- [ ] 依赖关系合理
- [ ] 易于扩展

---

## 问题处理流程

### 遇到阻塞时
1. 记录问题到 `PROGRESS.md`
2. 标记任务状态为 `BLOCKED`
3. 分析问题原因
4. 寻找解决方案或替代方案
5. 必要时调整计划

### Bug 修复流程
1. 复现 Bug
2. 编写失败的测试用例
3. 修复代码
4. 验证测试通过
5. 记录到 `PROGRESS.md`

---

## 总结

遵循此工作流程,确保:
1. **任务拆分清晰**: 每个任务可独立完成和测试
2. **进度可追踪**: 随时知道完成了什么,还剩什么
3. **质量有保障**: 每个功能都经过测试验证
4. **文档同步**: 代码和文档同步更新
5. **可回溯**: 出问题时可以快速定位

开始每个新任务前,问自己:
- 这个任务的输入输出是什么?
- 如何测试这个功能?
- 完成后如何验证?
- 需要更新哪些文档?
